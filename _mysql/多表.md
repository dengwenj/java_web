## 多表设计-概述
* 项目开发中，在进行数据库表结构设计时，会根据业务需求及业务模块之间的关系，
* 分析并设计表结构，由于业务之间相互关联，所以各个表结构之间也存在各种联系，基本上分为三种：
* 1、一对多(多对一)
* 2、多对多
* 3、一对一

## 一对多关系实现
* 在数据库表中多的一方，添加字段，来关联一的一方的主键

## 多表问题分析
* 部门数据可以直接删除，然而还有部门员工归属该部门下，此时就出现了数据的不完整、不一致问题

## 问题分析
* 目前上述的两张表，在数据库层面，并未建立关联，所以是无法保证数据的一致性和完整性的

## 外键约束
* 外键语法：
* create table 表名 (
* 字段名 数据类型,
* 【constraint】【外键名称】foreign key （外键字段名）references 主表（字段名）
* );
* 建完表后，添加外键
* alter table 表名 add constraint 外键名称 foreign key (外键字段名) references 主表(字段名);

## 物理外键
* 概念：使用 foreign key 定义外键关联另外一张表
* 缺点：
* 1、影响增、删、改的效率（需要检查外键关系）
* 2、仅用于单节点数据库，不适用于分布式、集群场景
* 3、容易引发数据库的死锁问题，消耗性能

## 逻辑外键
* 概念：在业务层逻辑中，解决外键关联
* 通过逻辑外键，就可以很方便的解决上述问题

## 一对一
* 案例：用户与身份证信息的关系
* 关系：一对一关系，多用于单表拆分，将一张表的基础字段放在一张表中，其他字段放在另一张表中，以提升操作效率
* 实现：在任意一方加入外键，关联另外一方的主键，并且设置外键为唯一的（unique）
```mysql
create table tb_user_card
(
    id int unsigned primary key auto_increment comment 'ID',
    nationality varchar(10) not null comment '民族',
    birthday date not null comment '生日',
    id_card char(18) not null comment '身份证号',
    is_sued varchar(20) not null comment '签发机关',
    expire_begin date not null comment '有效期限-开始',
    expire_end date comment '有效期限-结束',
    user_id int unsigned not null unique comment '用户ID',
    constraint fk_user_id foreign key (user_id) references tb_user (id)
) comment '用户信息表';
```

## 多对多
* 案例：学生与课程的关系
* 关系：一个学生可以选修多门课程，一门课程也可以供多个学生选择
* 实现：建立第三张中间表，中间表至少包含两个外键，分别关联两方主键
```mysql
create table tb_student
(
    id int unsigned primary key auto_increment comment 'ID',
    name varchar(10) not null comment '学生姓名',
    no varchar(20) not null unique comment '学号'
) comment '学生表';
insert into tb_student
values (null, '朴睦', '2018110'),
       (null, '李雷', '2018111'),
       (null, '韩梅梅', '2018112'),
       (null, '马旭', '2018113');

# 创建表
create table tb_course
(
    id int unsigned primary key auto_increment comment 'ID',
    name varchar(10) not null unique comment '课程名'
) comment '课程表';
insert into tb_course
values (null, 'java'),
       (null, 'javascript'),
       (null, 'mysql'),
       (null, 'golang');

# 多对多创建中间表，关联他们之间的id
create table tb_student_course
(
    id int unsigned primary key auto_increment comment 'ID',
    student_id int unsigned not null comment '学生id',
    course_id int unsigned not null comment '课程id',
    constraint fk_student_id foreign key (student_id) references tb_student (id),
    constraint fk_course_id foreign key (course_id) references tb_course (id)
) comment '学生课程关系表';
insert into tb_student_course
values (null, 1, 1),
       (null, 1, 2),
       (null, 2, 1),
       (null, 2, 1),
       (null, 3, 3),
       (null, 3, 4);
```

## 总结
* 一对多：在多的一方添加外键，关联另外一方的主键
* 一对一：任意一方，添加外键，关联另外一方的主键
* 多对多：通过中间表来维护，中间表的两个外键，分别关联另外两张表的主键

## 多表查询
* 指从多张表中查询数据
* 笛卡尔积：笛卡尔乘积是指在数学中，两个集合（A集合和B集合）的所有组合情况。（在多表查询时，需要消除无效的笛卡尔积）

## 连接查询
* 内连接：相当于查询A、B交集部分数据
* 外连接：
* 1、左外连接：查询左表所有数据（包括两张表交集部分数据）
* 2、右外连接：查询右表所有数据（包括两张表交集部分数据）

## 子查询

## 内连接
* 隐式内连接：select 字段列表 from 表1, 表2 where 条件...;
* 显示内连接：select 字段列表 from 表1 【inner】join 表2 on 连接条件...;
```mysql
# 查询员工的姓名，及所属的部门名称（隐式内连接实现）
select tb_emp.name, tb_dept.name from tb_emp, tb_dept where tb_emp.dept_id = tb_dept.id;
select e.name eName, d.name dName from tb_emp e, tb_dept d where e.dept_id = d.id;
 
# 查询员工的姓名，及所属的部门名称（显式内连接实现）
select e.name, d.name from tb_emp e inner join tb_dept d on e.dept_id = d.id;
```

## 外连接
* 左外连接：select 字段列表 from 表1 left【outer】join 表2 on 连接条件...;
* 右外连接：select 字段列表 from 表1 right【outer】join 表2 on 连接条件...;
```mysql
# 外连接
# 查询员工表所有员工的姓名，和对应的部门名称（左外连接）
select tb_emp.name, tb_dept.name
from tb_emp
         left join tb_dept on tb_emp.dept_id = tb_dept.id;

# 查询部门表所有部门的名称，和对应的员工名称（右外连接）
select e.name, d.name
from tb_emp e
         right join tb_dept d on e.dept_id = d.id;

select d.name, e.name
from tb_dept d
         left join tb_emp e on d.id = e.dept_id;
```